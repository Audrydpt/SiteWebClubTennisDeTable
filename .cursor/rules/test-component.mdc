---
description: 
globs: 
alwaysApply: true
---
= Writing test =
When a user wants to write tests, consider these aspects:


1. Basic Rendering Tests (Always Required):
   - Test component renders without crashing
   - Test component accepts and applies className prop correctly
   - Test all default props render correctly
   - Test all custom props render correctly
   - Test children render correctly (if component accepts children)
   - Test required props are enforced
2. Test positive cases (what should happen)
3. Test negative cases (what should NOT happen)
4. Test edge cases
5. For event handlers and callbacks:
   - Test they are called when they should be
   - Test they are NOT called when they should not be
6. For components with destructive actions:
   - Always test that cancellation/abort works correctly
   - Verify destructive actions don't occur without explicit confirmation

You should write them, even if the tests might fail because the component is poorly written. When testing, we should test all edge cases to ensure robustness. The goal is to detect bad scenarios, not just to have the tests succeed.

After writing a test, run it ! If it fail, fix it until you make it. You might need to fix a bug inside the component being tested. However, NEVER ADD "data-testid" or similar to component to target sutff in it.


= Test template =
```ts
describe('TestTemplate', () => {

  const renderComponent = (props = {}) => {
    const defaultProps = {
      onValueChange: vi.fn(),
    };

   // ... COMPLETE HERE
  };

  describe('Basic Rendering', () => {
   // ... COMPLETE HERE
  });

  describe('Interaction Tests', () => {
   // ... COMPLETE HERE
  });

  describe('Edge Cases', () => {
   // ... COMPLETE HERE
  });
});
```

= Running test =
To run a test, you must move to the main project directory "frontend". 
Then you have to select correct node version using nvm use --lts.
After all, you can safely run the wanted file using npm.

Quick go: "cd frontend ; nvm use --lts && npm test src/examples/examples.test.tsx"

= JSDOM & NextJS problem =
NextJS use portal, so it's might be difficult to write test correctly.
Consider using "screen.getByxxx" to target specific element. Use role, label, than text if previous was not possible.
Consider using "fireEvent.xxxx" to mimick user input.
NEVER USE "data-testid" or similar to target elements.

You have example of good JSDOM/NextJS test here:
- components/where-clauses.tsx => components/where-clauses.test.tsx
- features/settings/components/users.tsx => features/settings/components/users.test.tsx

= Element Selection Strategy =
When targeting elements with common text that appears multiple times:
- Use the most specific selector possible (role + name + location)
- Always prefer `within()` to scope queries to specific parent elements
- For dialog content, always target elements within the dialog using within(dialog).getByXXX
- Use precise role selectors with name filters:
  ```ts
  // For buttons with similar text
  const button = screen.getByRole('button', { 
    name: (content) => content.includes('Create') && !content.includes('Delete')
  });
  
  // For headings specifically
  const title = within(dialog).getByRole('heading', { level: 2, name: /Title/ });
  ```

= Dialog & Portal Testing =
For testing dialog/modal components:
1. Always query for the dialog first:
   ```ts
   const dialog = screen.getByRole('dialog');
   expect(dialog).toBeInTheDocument();
   ```

2. Use `within(dialog)` for all content queries inside the dialog:
   ```ts
   const dialogContent = within(dialog).getByText('Dialog content');
   ```

3. Handle multiple identical texts:
   - When text appears in multiple places, use `getAllByText()` and check length:
     ```ts
     const dialogContent = within(dialog).getAllByText(/Title/i);
     expect(dialogContent.length).toBeGreaterThan(0);
     ```

4. For complex UI tests involving dialogs:
   - Test opening dialog
   - Test dialog content is displayed correctly
   - Test dialog can be closed (via close button, cancel button, outside click)
   - Test dialog interactions (form inputs, buttons, etc.)
   - Test edge cases (loading states, errors, etc.)

= ShadCN Component Testing =
ShadCN components often render multiple instances of text in different parts of the component tree:
- Card titles appear in both CardHeader and CardTitle components
- Dialog titles appear in DialogHeader, DialogTitle, and sometimes in content
- When tests fail due to duplicate elements, use these strategies:

1. Always check the DOM structure first when targeting is difficult:
   ```ts
   screen.debug(); // Outputs the current DOM structure
   ```

2. For complex components:
   - Use more specific selectors combining role, text, and context
   - Check for existence rather than specific count when appropriate
   - Test functional behavior vs. exact DOM structure when possible
   - Use userEvent for interaction tests instead of fireEvent when possible
