---
description: 
globs: 
alwaysApply: true
---
= Writing test =
When a user wants to write tests, consider these aspects:


1. Basic Rendering Tests (Always Required):
   - Test component renders without crashing
   - Test component accepts and applies className prop correctly
   - Test all default props render correctly
   - Test all custom props render correctly
   - Test children render correctly (if component accepts children)
   - Test required props are enforced
2. Test positive cases (what should happen)
3. Test negative cases (what should NOT happen)
4. Test edge cases
5. For event handlers and callbacks:
   - Test they are called when they should be
   - Test they are NOT called when they should not be
6. For components with destructive actions:
   - Always test that cancellation/abort works correctly
   - Verify destructive actions don't occur without explicit confirmation

You should write them, even if the tests might fail because the component is poorly written. When testing, we should test all edge cases to ensure robustness. The goal is to detect bad scenarios, not just to have the tests succeed.

After writing a test, run it ! If it fail, fix it until you make it. You might need to fix a bug inside the component being tested. However, NEVER ADD "data-testid" or similar to component to target sutff in it.


= Test template =
```ts
describe('TestTemplate', () => {

  const renderComponent = (props = {}) => {
    const defaultProps = {
      onValueChange: vi.fn(),
    };

   // ... COMPLETE HERE
  };

  describe('Basic Rendering', () => {
   // ... COMPLETE HERE
  });

  describe('Interaction Tests', () => {
   // ... COMPLETE HERE
  });

  describe('Edge Cases', () => {
   // ... COMPLETE HERE
  });
});
```

= Running test =
To run a test, you must move to the main project directory "frontend". 
Then you have to select correct node version using nvm use --lts.
After all, you can safely run the wanted file using npm.

Quick go: "cd frontend ; nvm use --lts && npm test src/examples/examples.test.tsx"

= JSDOM & NextJS problem =
NextJS use portal, so it's might be difficult to write test correctly.
Consider using "screen.getByxxx" to target specific element. Use role, label, than text if previous was not possible.
Consider using "fireEvent.xxxx" to mimick user input.
NEVER USE "data-testid" or similar to target elements.

You have example of good JSDOM/NextJS test here:
- components/where-clauses.tsx => components/where-clauses.test.tsx
- features/settings/components/users.tsx => features/settings/components/users.test.tsx

= Element Selection Strategy =
When targeting elements with common text that appears multiple times:
- Use the most specific selector possible (role + name + location)
- Always prefer `within()` to scope queries to specific parent elements
- For dialog content, always target elements within the dialog using within(dialog).getByXXX
- Use precise role selectors with name filters:
  ```ts
  // For buttons with similar text
  const button = screen.getByRole('button', { 
    name: (content) => content.includes('Create') && !content.includes('Delete')
  });
  
  // For headings specifically
  const title = within(dialog).getByRole('heading', { level: 2, name: /Title/ });
  ```

= Dialog & Portal Testing =
For testing dialog/modal components:
1. Always query for the dialog first:
   ```ts
   const dialog = screen.getByRole('dialog');
   expect(dialog).toBeInTheDocument();
   ```

2. Use `within(dialog)` for all content queries inside the dialog:
   ```ts
   const dialogContent = within(dialog).getByText('Dialog content');
   ```

3. Handle multiple identical texts:
   - When text appears in multiple places, use `getAllByText()` and check length:
     ```ts
     const dialogContent = within(dialog).getAllByText(/Title/i);
     expect(dialogContent.length).toBeGreaterThan(0);
     ```

4. For complex UI tests involving dialogs:
   - Test opening dialog
   - Test dialog content is displayed correctly
   - Test dialog can be closed (via close button, cancel button, outside click)
   - Test dialog interactions (form inputs, buttons, etc.)
   - Test edge cases (loading states, errors, etc.)

= ShadCN Component Testing =
ShadCN components often render multiple instances of text in different parts of the component tree:
- Card titles appear in both CardHeader and CardTitle components
- Dialog titles appear in DialogHeader, DialogTitle, and sometimes in content
- When tests fail due to duplicate elements, use these strategies:

1. Always check the DOM structure first when targeting is difficult:
   ```ts
   screen.debug(); // Outputs the current DOM structure
   ```

2. For complex components:
   - Use more specific selectors combining role, text, and context
   - Check for existence rather than specific count when appropriate
   - Test functional behavior vs. exact DOM structure when possible
   - Use userEvent for interaction tests instead of fireEvent when possible

= Testing Forms and Dialogs =

When testing components with forms in dialogs (like FormDashboard):

1. Form submission:
   ```ts
   // For forms without explicit role attributes
   const form = within(dialog).querySelector('form');
   fireEvent.submit(form);
   
   // If submit button click is needed instead
   const submitButton = within(dialog).getByRole('button', { name: /submit|save|add/i });
   userEvent.click(submitButton);
   ```

2. Dialog testing strategy:
   - First test dialog opens correctly
   - Then test form input interaction
   - Finally test form submission and resulting API calls
   ```ts
   // Test dialog opening
   const trigger = screen.getByRole('button', { name: 'Open Dialog' });
   await userEvent.click(trigger);
   const dialog = screen.getByRole('dialog');
   expect(dialog).toBeInTheDocument();
   
   // Test form interaction within dialog context
   const input = within(dialog).getByRole('textbox');
   await userEvent.type(input, 'New Value');
   
   // Test submission
   const form = dialog.querySelector('form');
   fireEvent.submit(form);
   
   // Assert API was called
   await waitFor(() => {
     expect(mockApi.create).toHaveBeenCalledWith({ value: 'New Value' });
   });
   ```

3. Mocking considerations:
   - Mock API hooks with resolved promises for success cases
   ```ts
   const mockHook = {
     query: { isLoading: false, isError: false, data: mockData },
     create: vi.fn().mockResolvedValue({ id: 'new-id' }),
     update: vi.fn().mockResolvedValue(true),
     remove: vi.fn().mockResolvedValue(true),
   };
   ```

4. Element selection strategies:
   - For elements without semantic roles, use querySelector as fallback
   - For inconsistently labeled elements, use regular expressions
   ```ts
   // Use within() to scope queries to a specific container
   const dialog = screen.getByRole('dialog');
   
   // For elements that might not have proper roles
   const form = dialog.querySelector('form');
   
   // For buttons with variable text but consistent purpose
   const submitButton = within(dialog).getByRole('button', { 
     name: (content) => /submit|save|add/i.test(content) 
   });
   ```

5. Testing asynchronous operations:
   - Always use waitFor when testing state changes after async operations
   - Provide specific assertions in waitFor to catch exactly what failed
   ```ts
   await waitFor(() => {
     expect(mockApi.create).toHaveBeenCalledWith(expectedArgs);
     expect(mockNavigate).toHaveBeenCalledWith(expectedPath);
   });
   ```

= Testing Toast Notifications and Complex UI Elements =

## Toast Notification Testing Strategy
When testing toasts and other callback-driven functionality:
1. Test the logic directly rather than through form events:
   ```ts
   // Instead of simulating form submit and hoping toast gets called
   it('should show toast on success', () => {
     // Test toast function directly
     const successFn = () => toast('success.message', { description: 'success.description' });
     successFn();
     expect(toast).toHaveBeenCalledWith('success.message', expect.objectContaining({
       description: 'success.description'
     }));
   });
   ```

## JSDOM Limitations
Complex UI elements like sliders may not work properly in JSDOM:
- setPointerCapture is not supported in JSDOM
- Prefer testing value changes directly rather than simulating interactions
- For ShadCN components like Slider, test value changes with fireEvent.change instead of trying to simulate click

= Testing Checkbox Interactions =

When testing checkboxes, there are several common challenges and best practices to ensure reliable tests:

1. Targeting checkboxes:
   - Prefer using `getByLabelText()` over `getByRole('checkbox')` when possible:
     ```ts
     // More reliable than indexing into getAllByRole('checkbox')
     const checkbox = screen.getByLabelText('Option name');
     ```
   
   - If using `getByRole`, add a name matcher for clarity:
     ```ts
     const checkbox = screen.getByRole('checkbox', { name: 'Option name' });
     ```

2. Checkbox interaction:
   - Use `fireEvent.click()` for more reliable checkbox toggling:
     ```ts
     // More reliable than userEvent.click() for checkboxes
     fireEvent.click(checkbox);
     ```
   
   - Always verify checkbox state after interaction:
     ```ts
     fireEvent.click(checkbox);
     expect(checkbox).toBeChecked();  // or not.toBeChecked()
     ```

3. Handling ShadCN and custom checkboxes:
   - For complex UI where direct checkbox click doesn't work, try clicking on the label:
     ```ts
     const label = screen.getByText('Option name');
     userEvent.click(label);
     ```
   
   - For checkbox groups, first find the container, then target within it:
     ```ts
     const checkboxGroup = screen.getByRole('group', { name: 'Options' });
     const specificCheckbox = within(checkboxGroup).getByLabelText('Option 1');
     ```

4. Debugging checkbox issues:
   - Use `screen.debug()` to see the entire DOM structure:
     ```ts
     screen.debug(checkbox);  // Show just the checkbox
     ```
   
   - Check for CSS interference by examining computed styles:
     ```ts
     console.log(window.getComputedStyle(checkbox));
     ```

5. Testing select/deselect all functionality:
   - Test "Select All" and "Deselect All" button functionality separately:
     ```ts
     // Test Deselect All
     await userEvent.click(screen.getByText('Deselect All'));
     const checkboxes = screen.getAllByRole('checkbox');
     checkboxes.forEach(checkbox => expect(checkbox).not.toBeChecked());
     
     // Test Select All
     await userEvent.click(screen.getByText('Select All'));
     checkboxes.forEach(checkbox => expect(checkbox).toBeChecked());
     ```
   
   - When testing filtered selection, first verify the filtered view:
     ```ts
     // Filter items
     await userEvent.type(screen.getByPlaceholderText('Search...'), 'Option 1');
     
     // Verify only filtered items are visible
     expect(screen.getByText('Option 1')).toBeInTheDocument();
     expect(screen.queryByText('Option 2')).not.toBeInTheDocument();
     
     // Test Select All on filtered items
     await userEvent.click(screen.getByText('Select All'));
     expect(screen.getByLabelText('Option 1')).toBeChecked();
     ```

6. Clean state for tests:
   - Always ensure a clean initial state before testing selection changes:
     ```ts
     // Reset to a known state before each test
     beforeEach(() => {
       // Component rendering
       renderComponent();
       
       // Ensure clean state
       userEvent.click(screen.getByText('Deselect All'));
     });
     ```